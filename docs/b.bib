
@inproceedings{borzacchiello_fuzzing_2021,
	title = {Fuzzing {Symbolic} {Expressions}},
	url = {http://arxiv.org/abs/2102.06580},
	doi = {10.1109/ICSE43902.2021.00071},
	abstract = {Recent years have witnessed a wide array of results in software testing, exploring different approaches and methodologies ranging from fuzzers to symbolic engines, with a full spectrum of instances in between such as concolic execution and hybrid fuzzing. A key ingredient of many of these tools is Satisfiability Modulo Theories (SMT) solvers, which are used to reason over symbolic expressions collected during the analysis. In this paper, we investigate whether techniques borrowed from the fuzzing domain can be applied to check whether symbolic formulas are satisfiable in the context of concolic and hybrid fuzzing engines, providing a viable alternative to classic SMT solving techniques. We devise a new approximate solver, FUZZY-SAT, and show that it is both competitive with and complementary to state-of-the-art solvers such as Z3 with respect to handling queries generated by hybrid fuzzers.},
	urldate = {2025-06-13},
	booktitle = {2021 {IEEE}/{ACM} 43rd {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Borzacchiello, Luca and Coppa, Emilio and Demetrescu, Camil},
	month = may,
	year = {2021},
	note = {arXiv:2102.06580 [cs]},
	keywords = {Computer Science - Cryptography and Security, Computer Science - Software Engineering},
	pages = {711--722},
	file = {Full Text PDF:C\:\\zoteroCite\\storage\\YAJHE9L5\\Borzacchiello 等 - 2021 - Fuzzing Symbolic Expressions.pdf:application/pdf;Snapshot:C\:\\zoteroCite\\storage\\6PDF23AC\\2102.html:text/html},
}

@inproceedings{de_moura_z3_2008,
	title = {Z3: an efficient {SMT} solver},
	url = {https://www.microsoft.com/en-us/research/publication/z3-an-efficient-smt-solver/},
	abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
	booktitle = {2008 {Tools} and {Algorithms} for {Construction} and {Analysis} of {Systems}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {de Moura, Leonardo and Bjørner, Nikolaj},
	month = mar,
	year = {2008},
	pages = {337--340},
}


@inproceedings{yun_qsym_2018,
	address = {Baltimore, MD, USA},
	title = {{QSYM}: {A} {Practical} {Concolic} {Execution} {Engine} {Tailored} for {Hybrid} {Fuzzing}},
	abstract = {Recently, hybrid fuzzing has been proposed to address the limitations of fuzzing and concolic execution by combining both approaches. The hybrid approach has shown its effectiveness in various synthetic benchmarks such as DARPA Cyber Grand Challenge (CGC) binaries, but it still suffers from scaling to find bugs in complex, realworld software. We observed that the performance bottleneck of the existing concolic executor is the main limiting factor for its adoption beyond a small-scale study. To overcome this problem, we design a fast concolic execution engine, called QSYM, to support hybrid fuzzing. The key idea is to tightly integrate the symbolic emulation with the native execution using dynamic binary translation, making it possible to implement more fine-grained, so faster, instruction-level symbolic emulation. Additionally, QSYM loosens the strict soundness requirements of conventional concolic executors for better performance, yet takes advantage of a faster fuzzer for validation, providing unprecedented opportunities for performance optimizations, e.g., optimistically solving constraints and pruning uninteresting basic blocks. Our evaluation shows that QSYM does not just outperform state-of-the-art fuzzers (i.e., found 14× more bugs than VUzzer in the LAVA-M dataset, and outperformed Driller in 104 binaries out of 126), but also found 13 previously unknown security bugs in eight real-world programs like Dropbox Lepton, ffmpeg, and OpenJPEG, which have already been intensively tested by the stateof-the-art fuzzers, AFL and OSS-Fuzz.},
	language = {en},
	booktitle = {Proceedings of the 27th {USENIX} {Security} {Symposium} ({USENIX} {Security} 18)},
	publisher = {USENIX Association},
	author = {Yun, Insu and Lee, Sangho and Xu, Meng and Jang, Yeongjin and Kim, Taesoo},
	year = {2018},
	note = {cnname: 1},
	pages = {745--761},
	file = {Yun 等 - QSYM A Practical Concolic Execution Engine Tailor.pdf:C\:\\zoteroCite\\storage\\MEMWRDRX\\Yun 等 - QSYM A Practical Concolic Execution Engine Tailor.pdf:application/pdf},
}

@article{luk_pin_2005,
	title = {Pin: building customized program analysis tools with dynamic instrumentation},
	volume = {40},
	issn = {0362-1340, 1558-1160},
	shorttitle = {Pin},
	abstract = {Robust and powerful software instrumentation tools are essential for program analysis tasks such as profiling, performance evaluation, and bug detection. To meet this need, we have developed a new instrumentation system called
              Pin
              . Our goals are to provide
              easy-to-use, portable, transparent
              , and
              efficient
              instrumentation. Instrumentation tools (called
              Pintools
              ) are written in C/C++ using Pin's rich API. Pin follows the model of ATOM, allowing the tool writer to analyze an application at the instruction level without the need for detailed knowledge of the underlying instruction set. The API is designed to be
              architecture independent
              whenever possible, making Pintools source compatible across different architectures. However, a Pintool can access architecture-specific details when necessary. Instrumentation with Pin is mostly
              transparent
              as the application and Pintool observe the application's original, uninstrumented behavior. Pin uses
              dynamic compilation
              to instrument executables while they are running. For efficiency, Pin uses several techniques, including inlining, register re-allocation, liveness analysis, and instruction scheduling to optimize instrumentation. This fully automated approach delivers significantly better instrumentation performance than similar tools. For example, Pin is 3.3x faster than Valgrind and 2x faster than DynamoRIO for basic-block counting. To illustrate Pin's versatility, we describe two Pintools in daily use to analyze production software. Pin is publicly available for Linux platforms on four architectures: IA32 (32-bit x86), EM64T (64-bit x86), Itanium®, and ARM. In the ten months since Pin 2 was released in July 2004, there have been over 3000 downloads from its website.},
	language = {en},
	number = {6},
	urldate = {2024-04-26},
	journal = {ACM SIGPLAN Notices},
	author = {Luk, Chi-Keung and Cohn, Robert and Muth, Robert and Patil, Harish and Klauser, Artur and Lowney, Geoff and Wallace, Steven and Reddi, Vijay Janapa and Hazelwood, Kim},
	month = jun,
	year = {2005},
	note = {cnname: 1},
	pages = {190--200},
	file = {Full Text PDF:C\:\\zoteroCite\\storage\\MEN3VYPN\\Luk 等 - 2005 - Pin building customized program analysis tools wi.pdf:application/pdf},
}

@inproceedings{cadar_klee_2008,
	address = {San Diego, California, USA},
	title = {{KLEE}: {Unassisted} and {Automatic} {Generation} of {High}-{Coverage} {Tests} for {Complex} {Systems} {Programs}},
	abstract = {We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achieve high coverage on a diverse set of complex and environmentally-intensive programs. We used KLEE to thoroughly check all 89 stand-alone programs in the GNU COREUTILS utility suite, which form the core user-level environment installed on millions of Unix systems, and arguably are the single most heavily tested set of open-source programs in existence. KLEE-generated tests achieve high line coverage — on average over 90\% per tool (median: over 94\%) — and signiﬁcantly beat the coverage of the developers’ own hand-written test suite. When we did the same for 75 equivalent tools in the BUSYBOX embedded system suite, results were even better, including 100\% coverage on 31 of them.},
	language = {en},
	booktitle = {Proceedings of the 8th {USENIX} {Symposium} on {Operating} {Systems} {Design} and {Implementation}({OSDI})},
	author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
	year = {2008},
	pages = {209--224},
	file = {Cadar 等 - KLEE Unassisted and Automatic Generation of High-.pdf:C\:\\zoteroCite\\storage\\ZT9VIXS9\\Cadar 等 - KLEE Unassisted and Automatic Generation of High-.pdf:application/pdf},
}

@phdthesis{lattner_llvm_2002,
	address = {Urbana, IL},
	title = {{LLVM}: {AN} {INFRASTRUCTURE} {FOR} {MULTI}-{STAGE} {OPTIMIZATION}},
	language = {en},
	school = {University of Illinois at Urbana-Champaign},
	author = {Lattner, Chris Arthur},
	year = {2002},
	file = {Lattner - LLVM AN INFRASTRUCTURE FOR MULTI-STAGE OPTIMIZATI.pdf:C\:\\zoteroCite\\storage\\WPSD947K\\Lattner - LLVM AN INFRASTRUCTURE FOR MULTI-STAGE OPTIMIZATI.pdf:application/pdf},
}
@inproceedings{poeplau_symbolic_2020,
	title = {Symbolic execution with {SYMCC}: {Don}’t interpret, compile!},
	abstract = {A major impediment to practical symbolic execution is speed, especially when compared to near-native speed solutions like fuzz testing. We propose a compilation-based approach to symbolic execution that performs better than state-of-the-art implementations by orders of magnitude. We present SYMCC, an LLVM-based C and C++ compiler that builds concolic execution right into the binary. It can be used by software developers as a drop-in replacement for clang and clang++, and we show how to add support for other languages with little effort. In comparison with KLEE, SYMCC is faster by up to three orders of magnitude and an average factor of 12. It also outperforms QSYM, a system that recently showed great performance improvements over other implementations, by up to two orders of magnitude and an average factor of 10. Using it on real-world software, we found that our approach consistently achieves higher coverage, and we discovered two vulnerabilities in the heavily tested OpenJPEG project, which have been conﬁrmed by the project maintainers and assigned CVE identiﬁers.},
	language = {en},
	booktitle = {Proceedings of the 29th {USENIX} {Security} {Symposium} ({USENIX} {Security} 20)},
	publisher = {USENIX Association},
	author = {Poeplau, Sebastian and Francillon, Aurélien},
	year = {2020},
	pages = {181--198},
	file = {Poeplau 和 Francillon - Symbolic execution with SYMCC Don’t interpret, co.pdf:C\:\\zoteroCite\\storage\\5L9JHVWC\\Poeplau 和 Francillon - Symbolic execution with SYMCC Don’t interpret, co.pdf:application/pdf},
}


@inproceedings{she_fox_2024,
	address = {New York, NY, USA},
	series = {{CCS} '24},
	title = {{FOX}: {Coverage}-guided {Fuzzing} as {Online} {Stochastic} {Control}},
	isbn = {9798400706363},
	shorttitle = {{FOX}},
	url = {https://dl.acm.org/doi/10.1145/3658644.3670362},
	doi = {10.1145/3658644.3670362},
	abstract = {Fuzzing is an effective technique for discovering software vulnerabilities by generating random test inputs and executing them against the target program. However, fuzzing large and complex programs remains challenging due to difficulties in uncovering deeply hidden vulnerabilities. This paper addresses the limitations of existing coverage-guided fuzzers, focusing on the scheduler and mutator components. Existing schedulers suffer from information sparsity and the inability to handle fine-grained feedback metrics. The mutators are agnostic of target program branches, leading to wasted computation and slower coverage exploration.To overcome these issues, we propose an end-to-end online stochastic control formulation for coverage-guided fuzzing. Our approach incorporates a novel scheduler and custom mutator that can adapt to branch logic, maximizing aggregate edge coverage achieved over multiple stages. The scheduler utilizes fine-grained branch distance measures to identify frontier branches, where new coverage is likely to be achieved. The mutator leverages branch distance information to perform efficient and targeted seed mutations, leading to robust progress with minimal overhead.We present FOX, a proof-of-concept implementation of our control-theoretic approach, and compare it to industry-standard coverage-guided fuzzers. 6 CPU-years of extensive evaluations on the FuzzBench dataset and complex real-world programs (a total of 38 test programs) demonstrate that FOX outperforms existing state-of-the-art fuzzers, achieving average coverage improvements up to 26.45\% in real-world standalone programs and 6.59\% in FuzzBench programs over the state-of-the-art AFL++. In addition, it uncovers 20 unique bugs in popular real-world applications, including eight that are previously unknown, showcasing real-world security impact.},
	urldate = {2025-04-11},
	booktitle = {Proceedings of the 2024 on {ACM} {SIGSAC} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {Association for Computing Machinery},
	author = {She, Dongdong and Storek, Adam and Xie, Yuchong and Kweon, Seoyoung and Srivastava, Prashast and Jana, Suman},
	month = dec,
	year = {2024},
	pages = {765--779},
	file = {Full Text PDF:C\:\\zoteroCite\\storage\\KVBBL5SW\\She 等 - 2024 - FOX Coverage-guided Fuzzing as Online Stochastic .pdf:application/pdf},
}
