#import "template.typ": *
#import "authors.typ": *
#show: cactus-report.with(
  title_cn: [基于SMT求解和变量级变异的约束用例生成器],
  course_name: [软件分析与测试],
  authors: authors
)

= 需求分析

首先从输出、约束条件、输出等方面分析本项目的需求，可以分点概括如下。
1. 类C11语法文本输入：一个自定义的、以C语言语法为基础的约束描述文件。这个文件包含：
  - 数据结构定义: typedef struct，定义了复合数据类型。
  - 全局变量声明: int a;, int b[3];, struct S1 s[2]; 等，这些是我们要生成值的“目标变量”。
  - 特殊函数声明: \_LENGTH, GAUSSIAN。这些不是标准的C函数，而是对约束系统的“元指令”，需要特殊处理。
  - 约束函数: \_CONSTRAINT() 函数体内的表达式集合，它们是核心的约束规则。
2. 约束条件：
  - 布尔与算术约束: a > 5 && a < 10, a + b[0] != s[0].a。这些是典型的SMT（Satisfiability Modulo Theories）求解器可以直接处理的。
  - 数组/结构体约束: 约束涉及数组元素 (b[1]) 和结构体成员 (s[0].a)。
  - 元约束:
    - \_LENGTH(s[0].d) > 6: 这不是对指针d的值进行约束，而是对其指向的内存区域的“长度”进行约束。这实际上是在定义一个动态分配的数组的维度。
    - GAUSSIAN(s[0].c, 1.0, 1.0): 这不是一个真/假判断，而是一个生成性约束或概率分布约束。它指示变量s[0].c的值应该从一个高斯分布中采样。
3. 输出：
  - 正例：一组满足所有约束的变量赋值。
  - 负例：一组故意违反至少一个约束的变量赋值。理想情况下，可以精确控制违反哪一条。
  - 格式: 清晰的键值对，如 a=7; b[0]=1; ...。
4. 其它需求：
    - 并行生成: 系统应能部署在多台机器上，协同工作。
    - 用例不重复: 并行生成的用例集合中，不应有重复的用例。
#h(2em)本项目的难点在于首先，如何将这个C11-like的文本文件，准确地转换成机器可处理的结构？需要解析变量声明、类型定义和约束表达式。其次， 如何将不同类型的约束（算术、逻辑、元约束）统一到一个模型中？特别是 \_LENGTH 和 GAUSSIAN 这种非标准约束，Z3等标准求解器无法直接理解。以及如何系统性地、有针对性地生成违反特定约束的用例，而不是随机地产生一个无效数据。

= 解决思路

