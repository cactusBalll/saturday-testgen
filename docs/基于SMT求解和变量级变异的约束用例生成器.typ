#import "template.typ": *
#import "authors.typ": *
#show: cactus-report.with(
  title_cn: [基于SMT求解和变量级变异的约束用例生成器],
  course_name: [软件分析与测试],
  authors: authors
)

= 需求分析

在软件测试，特别是系统级和单元测试中，构造高质量的测试用例是一项耗时且复杂的任务。测试用例需要覆盖各种边界条件和复杂逻辑路径，以确保代码的健壮性和正确性。手动编写这些用例不仅效率低下，而且容易遗漏关键场景。
本项目旨在解决这一痛症，目标是开发一个自动化、高效、可定制的测试用例生成器。该生成器能够解析以C11语法子集定义的变量及其约束关系，并自动生成大量满足（或不满足）这些约束的测试数据。

首先从输出、约束条件、输出等方面分析本项目的需求，可以分点概括如下。


1. 类C11语法文本输入：一个自定义的、以C语言语法为基础的约束描述文件。这个文件包含：
  - 数据结构定义: typedef struct，定义了复合数据类型。
  - 全局变量声明: int a;, int b[3];, struct S1 s[2]; 等，这些是我们要生成值的“目标变量”。
  - 特殊函数声明: \_LENGTH, GAUSSIAN。这些不是标准的C函数，而是对约束系统的“元指令”，需要特殊处理。
  - 约束函数: \_CONSTRAINT() 函数体内的表达式集合，它们是核心的约束规则。
2. 约束条件：
  - 布尔与算术约束: a > 5 && a < 10, a + b[0] != s[0].a。这些是典型的SMT（Satisfiability Modulo Theories）求解器可以直接处理的。
  - 数组/结构体约束: 约束涉及数组元素 (b[1]) 和结构体成员 (s[0].a)。
  - 元约束:
    - \_LENGTH(s[0].d) > 6: 这不是对指针d的值进行约束，而是对其指向的内存区域的“长度”进行约束。这实际上是在定义一个动态分配的数组的维度。
    - GAUSSIAN(s[0].c, 1.0, 1.0): 这不是一个真/假判断，而是一个生成性约束或概率分布约束。它指示变量s[0].c的值应该从一个高斯分布中采样。
3. 输出：
  - 正例：一组满足所有约束的变量赋值。
  - 负例：一组故意违反至少一个约束的变量赋值。理想情况下，可以精确控制违反哪一条。
  - 格式: 清晰的键值对，如 a=7; b[0]=1; ...。
4. 其它需求：
    - 并行生成: 系统应能部署在多台机器上，协同工作。
    - 用例不重复: 并行生成的用例集合中，不应有重复的用例。
#h(2em)本项目的难点在于首先，如何将这个C11-like的文本文件，准确地转换成机器可处理的结构？需要解析变量声明、类型定义和约束表达式。其次， 如何将不同类型的约束（算术、逻辑、元约束）统一到一个模型中？特别是 \_LENGTH 和 GAUSSIAN 这种非标准约束，Z3等标准求解器无法直接理解。以及如何系统性地、有针对性地生成违反特定约束的用例，而不是随机地产生一个无效数据。



= 架构设计

== 功能架构

系统采用流水线式的功能架构，将复杂的生成任务分解为一系列独立的、顺序执行的模块。多线程机制则并行运行此流水线。



1.  命令行解析模块：负责解析用户输入的参数（如 `-n`, `-p`, `-c`），为后续模块提供配置。
2.  并行执行管理模块：根据用户指定的线程数，创建多个工作线程，并将总任务量（正负例数量）合理分配给每个线程。
3.  约束解析模块 (ANTLR)：
    -   利用ANTLRv4生成的C11语法分析器，将输入的约束文件（`.c`）解析为一棵抽象语法树（AST）。这是对C代码进行结构化理解的第一步。
4.  符号化转换模块 (AST Visitor)：
    -   核心模块，通过遍历AST，将C代码中的实体和逻辑转换为数学化的符号表示。
    -   变量与符号表：识别C代码中的变量声明（如 `int a`, `S1 s[2]`），在内部维护一个符号表（`SymbolTable`），记录每个变量的名称、类型、维度等信息，并为其创建对应的Z3符号变量。
    -   约束与Z3表达式：遍历 `_CONSTRAINT()` 函数体内的表达式，将C的算术、关系和逻辑运算逐一翻译成等价的Z3约束表达式（`z3::expr`）。例如，C代码 `a > 5 && b[0] < 10` 会被转换为Z3中的逻辑与表达式 `And(a > 5, b_0 < 10)`。
5.  约束求解与诱变引擎 (Z3 + Custom Logic)：
    -   这是生成具体数值的核心。它接收符号化后的Z3约束，通过求解与变异策略生成满足条件的具体解。
        .
6.  用例序列化模块 (nlohmann/json)：
    1.   将求解引擎得到的具体数值解（即变量的一组赋值），按照变量名组织并序列化为符合输出格式的JSON对象。
7.  用例验证模块 (QuickJS)：
    -   在写入文件前，启动一个轻量级JavaScript引擎（QuickJS）。
    -   将原始的C约束逻辑动态转换为JS代码，并将序列化后的JSON用例作为输入，在JS环境中执行验证。
    -   只有通过验证的用例才会被最终输出，确保了100%的正确性。
8.  文件输出模块：将通过验证的JSON用例写入到指定的输出目录，并根据正负例和序号命名。

== 数据架构

系统在运行过程中处理和流转多种核心数据结构：

1.   抽象语法树 (AST - `antlr4::tree::ParseTree`)：由ANTLR生成的、对C约束文件的树状结构化表示，是所有分析的起点。
2.   符号表 (`ststgen::SymbolTable`)：一个分层的作用域哈希表，用于存储从AST中解析出的所有变量信息。其核心是 `SymbolTableEntry` 结构体，描述了变量的类型、限定符（如指针、数组）、维度、约束（如高斯分布参数）以及其对应的Z3符号。
3.   结构体蓝图 (`ststgen::StructBlueprint`)：用于存储`struct`类型的定义，包括其成员变量的名称、类型，以及Z3中对应的元组（Tuple）构造器和访问器函数。
4.   符号化约束 (`z3::expr`)：Z3库的核心数据结构，以数学形式表示变量间的约束关系。整个 `_CONSTRAINT()` 函数最终被表达为一个或多个 `z3::expr` 对象。
5.   测试用例 (`nlohmann::json`)：最终输出的数据形式，是一个JSON对象，易于解析和使用。

== 技术架构

本项目的实现依赖于一系列业界成熟的第三方库：

1.   C++17：作为主要的开发语言，利用其现代特性如 `std::optional`, `std::filesystem`, `std::thread` 等。
2.   ANTLRv4：一个强大的语法分析器生成器，用于解析C11语法，构建AST。
3.   Z3 SMT Solver (Microsoft)：世界领先的约束满足理论（SMT）求解器。是本项目的“大脑”，负责处理所有符号计算和约束求解任务。
4.   QuickJS：一个轻量、快速的嵌入式JavaScript引擎，用于在C++环境中执行独立的用例验证逻辑。
5.   nlohmann/json：一个现代C++的JSON库，用于方便地生成和处理JSON数据。
6.   cmdline.h：一个头文件式的C++命令行参数解析库。
7.   fmtlib：一个高性能的格式化库，用于日志和终端输出。

= 实现技术

== 功能项1: 快速生成多个正例

单纯依赖Z3求解器重复求解一个复杂的约束集合以获得不同解，效率较低。本项目采用了一种“分而治之”的引导性随机赋值策略（Guided Mutational Strategy）来加速正例生成：

1.  原子变量识别：在符号化转换阶段，系统不仅构建了总的约束表达式，还识别出表达式中的所有“原子变量”（如 `a`, `b[0]`, `s[1].a` 等），并将它们存入一个列表 `constraint_val_list` 中。
2.  随机化迭代：`mutateEntrance` 函数首先将此列表随机打乱，这为生成不同用例引入了初始多样性。
3.  逐一赋值与求解：系统通过 `mutateVar` 函数递归地遍历原子变量列表。对每个变量，它会：
    -   简化约束：基于已经赋过值的变量，简化与当前变量相关的约束，从而推导出该变量的有效取值范围（例如，从 `a > 5 && a < 10` 推导出 `a` 的范围是 `[6, 9]`）。
    -   随机选取：在计算出的有效范围内随机选取一个值。
    -   添加新约束并递归：将“`变量 == 选定值`”作为一个新的、临时的约束添加到Z3求解器中，然后继续为下一个变量赋值。
4.  最终求解：当所有（或部分关键）变量都被赋予具体值后，整个约束系统变得非常简单。此时调用Z3的 `check()` 和 `get_model()` 可以极快地获得一个完整解。

优势：此方法将一个复杂的多变量求解问题，降解为一系列简单的单变量范围推导和随机选择问题，极大地降低了Z3求解器的负担，从而能够快速、连续地生成大量不同的正例。

此外，对于 `||` (OR) 逻辑，系统会随机选择一个分支进行满足，进一步简化了求解空间，提高了用例的多样性。

== 功能项2: 快速生成多个负例

负例的定义是“不满足 `C`”，即满足 `!C`。如果 `C` 是 `C1 && C2 && ...`，则 `!C` 是 `!C1 || !C2 || ...`。直接求解这个庞大的“或”关系是低效的。

本项目采用了一种随机断言翻转（Random Assertion Flipping）的启发式方法：

1.  在`mutateEntrance`函数中，如果目标是生成负例（`positive == 'N'`），则会调用 `random_flip_expr` 函数。
2.  该函数获取原始的所有约束断言（`C1`, `C2`, ...），并随机地将其中一个或多个进行逻辑取反（例如，将 `a > 5` 变为 `!(a > 5)`，即 `a <= 5`）。
3.  然后，系统尝试求解这个被修改过的约束集合。
4.  由于修改后的约束集合必然与原始约束集的一个子集相悖，因此任何求出的解都一定是原始约束的负例。

优势：这种方法巧妙地避开了求解复杂析取范式，通过对原始约束进行微小但关键的“破坏”，快速构造出易于求解且保证为负例的新约束集。

== 功能项3: 多机并行生成不重复的用例

项目通过`main.cpp`中的逻辑实现了高效的多线程并行：

1.  任务划分：主线程根据用户设定的总用例数、正负例比例和线程数，计算出每个子线程需要生成的正、负例数量。
2.  独立实例：为每个子线程创建一个完全独立的 `CConstraintVisitor` 实例。这意味着每个线程都有自己的符号表、Z3求解器上下文和随机数生成器。
3.  随机化隔离：每个线程使用 `std::random_device` 获取不同的随机种子。由于每个线程的求解过程（特别是随机赋值和断言翻转）都依赖于这个独立的随机种子，它们会探索求解空间的不同部分，从而生成不同的用例。
4.  无锁设计：各线程在生成阶段完全独立，不共享任何可变数据，避免了线程同步开销。仅在最后输出日志时使用互斥锁（`std::mutex`）保证终端信息不交错。
5.  内部去重：在每个线程内部，`m_cases`被定义为 `std::unordered_set`，确保单个线程内不会产生重复的用例。

结论：通过任务划分和为每个线程提供独立的、随机初始化的求解环境，系统实现了高效、无冲突的并行用例生成，并保证了最终用例集的高度多样性和低重复率。

== 功能项4: 证明生成的例子符合给定约束

为保证最终交付用例的100%正确性，项目引入了基于QuickJS的独立验证机制：

1.  动态代码生成：在 `writeCases` 函数中，系统将原始C约束文件中的约束表达式（`m_cons_expressions`）拼接成一个JavaScript布尔表达式字符串。
2.  环境模拟：`_LENGTH` 和 `GAUSSIAN` 这两个C中的特殊函数，也被翻译成等价的JavaScript函数。
3.  执行与断言：
    -   将Z3求解器生成的JSON用例数据注入到QuickJS的全局作用域中。
    -   执行拼接好的JS约束表达式。
    -   获取JS脚本的布尔返回值。
4.  最终检查：
    -   如果目标是正例，则断言JS返回值为 `true`。
    -   如果目标是负例，则断言JS返回值为 `false`。
    -   只有通过断言检查的用例才会被写入文件。

优势：这是一个强大的端到端验证。它独立于核心的Z3求解流程，能有效地捕获从C代码到Z3符号、再到JSON数值整个转换链条中可能出现的任何错误，为用例的正确性提供了坚实的保障。

= 工具测试

为了验证生成器在功能上的完备性、正确性以及在性能上的高效性，我们设计并执行了一系列功能测试和性能基准测试。

== 功能测试

功能测试旨在验证工具是否能正确解析和处理C11语法子集中的各种变量声明和约束逻辑。我们编写了一系列具有针对性的约束文件，每个文件侧重于测试系统的某个特定方面。

#figure(
  table(
    columns: (1fr, 3fr),
    [测试用例文件], [测试目的],
    [simple_val.c],[基础功能验证：测试最简单的整型变量和基本关系运算（`>`、`<`、`==`）。],
    [free_array.c],[一维数组测试：验证对一维数组的声明、索引访问和约束处理],
    [ndim_array.c],[多维数组测试：验证对二维及更高维度数组的正确解析和符号化。],
    [cons3.c],[算术运算测试：集中测试加（`+`）、减（`-`）、乘（`*`）、除（`/`）、模（`%`）等算术表达式的转换与求解。],
    [cons4.c],[逻辑运算测试：测试逻辑与（`&&`）、逻辑或（`||`）、逻辑非（`!`）以及它们组合形成的复杂逻辑链。],
    [cons2.c],[结构体与指针约束：重点测试对`struct`的定义、`struct`数组成员的访问以及对指针的 `_LENGTH` 特殊原语约束。],
    [cons5.c],[混合约束测试：结合算术运算、结构体成员访问和数组索引，测试系统在复杂混合场景下的处理能力。],
    [cons1.c],[综合样例：作为提供给用户的标准样例，覆盖了大部分核心功能，包括基本类型、数组、结构体、`_LENGTH`和`GAUSSIAN`原语。],
    tlb_l()
  ),
  caption: [测试用例设计]
)

*测试结果：*
所有功能测试用例均成功执行。测试结果表明，本工具能够正确解析所有测试场景中的变量声明和约束逻辑，并生成符合预期的正例和负例。所有生成的用例均100%通过了独立的QuickJS验证流程，证明了工具在功能层面的正确性和健壮性。

== 性能测试

性能是衡量本工具实用性的关键指标，尤其是在需要生成大规模测试集的场景下。性能测试旨在评估工具在处理复杂约束时生成大量用例的效率，并验证多线程并行架构带来的性能提升。

*测试环境与设置：*

- 测试任务：生成10,000个正例和10,000个负例，共计20,000个测试用例。

- 约束文件 (`cons_complex.c`)：为充分评估工具在复杂场景下的性能，我们设计了一个包含多种数据结构和大量约束的 `cons_complex.c` 文件。该文件定义了多个结构体，声明了包含基本类型、数组、结构体数组在内的多种变量，并在 `_CONSTRAINT` 函数中设置了超过20条相互关联的约束。


*运行命令*：

  -   单线程：`./main -n 20000 -p 0.5 -c ./constraint-examples/cons_complex.c`
  -   多线程：`./main -n 20000 -p 0.5 -c ./constraint-examples/cons_complex.c -j 14`

=== 测试结果与分析

#figure(
  table(
    columns: (1fr, 1fr),
    [测试模式], [完成20,000个用例耗时(正负例各1/2)],
    [单线程],[> 20分钟],
    [多线程（14线程）],[约 3分钟],
    tlb_l()
  ),
  caption: [性能测试结果]
)

*结果分析*：

测试结果清晰地展示了多线程并行处理带来的巨大性能优势。

1.  单线程性能：在单线程模式下，面对`cons_complex.c`这样复杂的约束集，生成20,000个用例的耗时超过了20分钟。这反映了在复杂场景下，串行化地进行“范围推导 -> 随机赋值 -> 约束求解 -> 验证输出”这一系列操作，其计算成本是相当高的。

2.  多线程性能与加速比：切换到14线程并行模式后，完成相同任务的总时间锐减至约3分钟，性能提升了近7倍。这一显著提升得益于我们精心设计的并行架构：每个线程都在独立的求解环境和随机种子的引导下工作，任务被有效分摊到多个CPU核心上，且线程间无需通信和同步，有效避免了锁竞争和资源冲突。这使得计算能力能够随着核心数的增加而得到有效扩展。

== 测试结论

综合功能与性能测试，我们可以得出以下结论：

-   功能完备：本工具完整覆盖了设计需求，能够正确处理包括基本类型、多维数组、结构体、指针以及特殊原语在内的多种C语言特性和约束。
-   性能卓越：工具在处理复杂约束和大规模用例生成任务时表现出色，其多线程架构带来了显著的性能提升，在现代多核处理器上展现了卓越的扩展能力。

测试结果充分证明，该工具能够胜任在实际软件开发和测试项目中，快速、大批量地生成高质量、多样化测试用例的任务。



