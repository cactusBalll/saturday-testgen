#import "ori-xjle.typ": *
#import "authors.typ": *
#import "@preview/fletcher:0.5.8" as fletcher: diagram, node, edge, shapes
#set heading(numbering: numbly("{1:1}. ", default: "1.1  "))
#show: ori.with(
  author: authors,
  subject: "基于SMT求解和变量级变异的约束用例生成器",
  date: datetime.today(),
  maketitle: true,
  size: 12pt,
  first-line-indent: auto,
  makeoutline: true,
  course: "软件分析与测试",
  font: (
    main: "Times New Roman",
    mono: "Menlo",
    heading: "SimHei",
    cjk: "Songti SC",
    emph-cjk: "Songti SC",
    math: "New Computer Modern Math",
    math-cjk: "Noto Serif SC",
  )
)

= 需求分析

在软件测试，特别是系统级和单元测试中，构造高质量的测试用例是一项耗时且复杂的任务。测试用例需要覆盖各种边界条件和复杂逻辑路径，以确保代码的健壮性和正确性。手动编写这些用例不仅效率低下，而且容易遗漏关键场景。
为解决这一难题，本项目旨在开发一个自动化、高效、可定制的测试用例生成器。该生成器能够解析以C11语法子集定义的变量及其约束关系，并自动生成大量满足（或不满足）这些约束的测试数据。

从输入、约束条件、输出等方面对本项目的需求进行全面分析，概括如下：

1. *C11语法文本输入*：一个使用C11语法定义的约束描述文件。支持定义的类型有：
  - 数据结构定义: struct，定义了复合数据类型。
  - 特殊函数: \_LENGTH, GAUSSIAN。这些函数是约束系统中的“元指令”，需要特殊处理。
  - 约束函数: \_CONSTRAINT() 函数体内的表达式集合，它们是核心的约束规则。
2. *约束条件*：
  - 布尔与算术约束: 例如 a > 5 && a < 10, a + b[0] != s[0].a。这些是典型的SMT（Satisfiability Modulo Theories）求解器可以直接处理的。
  - 数组/结构体约束: 约束涉及数组元素 (如b[1]) 和结构体成员 (如s[0].a)。
  - 特殊约束:
    - \_LENGTH(void \*p) > 6: 这是对指针p指向的内存区域的数组长度进行约束，它表示动态内存p对应的长度应为给定值。
    - GAUSSIAN(s[0].c, 1.0, 1.0): 这是对变量概率分布的约束。它表示变量s[0].c的值应该服从给定的高斯分布。
3. *测试样例输出*
  - 正例：一组满足所有约束的变量赋值。
  - 负例：一组至少违反一个约束的变量赋值。
4. *其它需求*
    - 并行生成: 系统应能部署在多台机器上，协同工作。

= 架构设计

== 功能架构

本系统将复杂的样例生成任务分解为一系列独立的的功能模块，每个模块各司其职，互相合作，以便实现预期的效果。这些功能模块的介绍如下：

+  *命令行选项解析模块*：负责解析用户输入的参数（如 `-n`, `-p`, `-c`），生成全局的系统参数。
+  *并行执行管理模块*：根据用户指定的线程数，创建多个工作线程，并将总任务量（正负例数量）合理分配给每个线程。
+  *约束解析模块 (ANTLR)*：使用ANTLRv4生成C11语法分析器，通过该分析器可以将输入的约束文件（`.c`）解析为一棵抽象语法树（AST）。这是对C代码进行结构化理解的第一步。
+  *符号化转换模块 (AST Visitor)*：核心模块，通过遍历AST，将C代码中的实体和逻辑转换为Z3表达式，以便进一步处理。主要包含以下两个功能：
  -  变量与符号表：识别C代码中的变量声明（如 `int a`, `S1 s[2]`），并在程序内部维护一个符号表（`SymbolTable`），记录每个变量的名称、类型、维度等信息，并为其创建对应的Z3符号变量。
  -  约束与Z3表达式：遍历 `_CONSTRAINT()` 函数体内的表达式，将C的算术、关系和逻辑运算逐一翻译成等价的Z3约束表达式（`z3::expr`）。例如，C代码 `a > 5 && b[0] < 10` 会被转换为Z3中的逻辑与表达式:  `(and (a > 5) ((select b 0) < 10))`。
+  *约束求解器 (Z3)*：Z3 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定约束条件寻求一组满足条件的解的问题，通过Z3可以方便的求出满足条件的一组解。
+  *变量级变异模块*：这是本系统变异生成多组测试样例的核心模块。它根据原始约束，维护每个变量的可取范围，并递归的对约束变量依次进行变异，即对每个变量在其取值范围内随机赋予一个值，并向Z3求解器中动态增删变异赋值约束，从而实现快速生成大量测试样例的效果。
+  *用例序列化模块 (nlohmann/json)*：将求解引擎得到的具体数值解（即变量的一组赋值），按照变量名组织并序列化为符合输出格式的JSON对象。
+  *用例验证模块 (QuickJS)*：在本系统中，使用JavaScript对生成的样例进行快速验证。具体步骤：
    -   在将样例写入文件前，程序启动一个轻量级JavaScript引擎（QuickJS）。
    -   将原始的C约束逻辑动态转换为JS代码，并将序列化后的JSON用例作为输入，在JS环境中执行验证。
    -   只有通过验证的用例才会被最终输出，确保了100%的正确性。
+  *文件输出模块*：将通过验证的JSON用例写入到指定的输出目录，并根据正负例和序号命名。

== 数据架构

系统在运行过程中处理和流转的核心数据结构主要有：

1.   抽象语法树 (AST - `antlr4::tree::ParseTree`)：由ANTLR生成的、对C约束文件的树状结构化表示，是后续分析的起点。
2.   符号表 (`ststgen::SymbolTable`)：一个分层的作用域哈希表，用于存储从AST中解析出的所有变量信息。其核心是 `SymbolTableEntry` 结构体，描述了变量的类型、限定符（如指针、数组）、维度、约束（如高斯分布参数）以及其对应的Z3符号。
3.   结构体蓝图 (`ststgen::StructBlueprint`)：用于存储`struct`类型的定义，包括其成员变量的名称、类型，以及Z3中对应的元组（Tuple）构造器和访问器函数。
4.   符号化表达式 (`z3::expr`)：Z3库的核心数据结构，以数学形式表示变量间的约束关系。`_CONSTRAINT()` 函数中的每个C表达式最终都被表达为一个 `z3::expr` 对象。
5.   Z3求解器 (`z3::solver`)：求解器对象，可以向其中动态增删约束表达式，支持通过`check()`函数检查当前约束状态是否存在解，通过`solve()`函数可以求出一组可行解。
6.   约束变量数组（`std::vector<z3::expr>`）, 以及包含特定约束变量的约束表达式映射（`std::map<std::string, std::vector<z3::expr>>`）：这两个数据结构是用例变异过程中的使用的核心数据，其中约束变量数组保存了`_CONSTRAINT()`函数中所遇到的每一个原子变量（如单个int型变量`a`，数组的第i个元素`b[0]`， 数组长度`_LENGTH(s[0].d)`等），将其收集起来以便逐个进行变异生成；另外一个数据结构，即包含特定约束变量的约束表达式映射中，可以通过给定的变量名，快速检索出与之相关联的所有约束表达式，用于在变异中更新变量的取值范围。
7.   测试用例赋值 (`nlohmann::json`)：最终输出的数据形式，是一个JSON对象，易于其他软件解析和使用。

== 技术架构

在本项目的实现过程中，使用了以下业界成熟的第三方库：

1.   ANTLRv4：强大的语法分析器生成器，用于解析C11语法，构建AST。
2.   Z3 SMT Solver (Microsoft)：世界领先的约束满足理论（SMT）求解器。是本项目的“大脑”，负责处理所有符号计算和约束求解任务。
3.   QuickJS：轻量、快速的嵌入式JavaScript引擎，用于在C++环境中执行独立的用例验证逻辑。
4.   nlohmann/json：业界知名的用于处理JSON数据的头文件库。
5.   cmdline.h：用于C++命令行参数解析的头文件库。
6.   fmtlib：一个高性能的格式化库，用于日志和终端输出。

= 实现技术

== 功能项1: 快速生成多个正例

单纯依赖Z3求解器直接对原始约束集合求解，只能生成一组测试样例。为了快速生成多组测试样例，本项目采用了一种原创的变量级随机赋值策略（Variable-level Random Assignment Strategy）来进行样例生成，该算法流程图如图1所示：
#figure(
  text(
    size: 10pt,
    font: "SimHei",
  diagram(
    
    node-stroke: 1pt,

    node((0,0), [开始：解析C11约束文件\ 识别约束变量\ 构建约束变量集合`val_set` \ 建立约束变量表达式映射`val_expr_map` ], corner-radius: 2pt),
    edge("-|>"),
    node((0,1), [启动变异生成：`mutateVal(val_set.begin())`], corner-radius: 2pt),
    edge("-|>"),
    node((0,2), [对第`i`个变量进行变异生成：`mutateVal(val_i)`], corner-radius: 2pt),
    edge("-|>"),
    node((0,3), [`val_i == val_set.end() ?`], shape: shapes.diamond, height: 2em),
    edge("-|>", label: [是]),
    node((1,3), [求解\ 输出一组样例], corner-radius: 2pt),
    edge("-|>"),
    node((1,4), [递归终止\ 返回上一层], corner-radius: 2pt),
    edge((0,3), (0,4),"-|>",label: "否"),
    node((0,4), [遍历`val_expr_map`\ 检索包含`val_i`的所有约束表达式 \ 更新`val_i`取值范围], corner-radius: 2pt),
    edge("-|>"),
    node((0,5), [在`val_i`取值范围内\ 为`val_i`随机赋值], corner-radius: 2pt),
    edge("-|>"),
    node((0,6), [将`val_i`随机赋值作为约束\ 添加进SMT求解器中], corner-radius: 2pt),
    edge("-|>"),
    node((0,7), [求解器是否存在解 ?], shape: shapes.diamond, height: 2em),
    edge("-|>", label: "存在"),
    edge((0,7), "l,d,d,d,r","-|>", label: "不存在", label-pos: 10%),
    node((0,8), [求解并输出一组样例], corner-radius: 2pt),
    edge("-|>"),
    node((0,9), [递归变异下一个变量\ `mutateVal(val_i.next())`], corner-radius: 2pt),
    edge("-|>"),
    node((0,10), [在求解器中移除当前`val_i`的赋值约束], corner-radius: 2pt),
    edge("-|>"),
    edge((1,4),"d,d,d,d,d,d,l","-|>"),
    node((0,11), [结束], corner-radius: 2pt),
    )
  ),
  caption: [变异生成测试样例算法流程图]
)

每个步骤的详细介绍如下：
1.  原子变量识别：在符号化转换阶段，系统不仅构建了总的约束表达式，还识别出表达式中的所有“原子变量”（如 `a`, `b[0]`, `s[1].a` 等），并将它们存入一个列表 `constraint_val_list` 中。
2.  随机化迭代：`mutateEntrance` 函数首先将此列表随机打乱，这为生成不同用例引入了初始多样性。
3.  逐一赋值与求解：系统通过 `mutateVar` 函数递归地遍历原子变量列表。对每个变量，它会：
    -   简化约束：基于已经赋过值的变量，简化与当前变量相关的约束，从而推导出该变量的有效取值范围（例如，从 `a > 5 && a < 10` 推导出 `a` 的范围是 `[6, 9]`）。
    -   随机选取：在计算出的有效范围内随机选取一个值。
    -   添加新约束并递归：将“`变量 == 选定值`”作为一个新的、临时的约束添加到Z3求解器中，然后继续为下一个变量赋值。
4.  最终求解：当所有（或部分关键）变量都被赋予具体值后，整个约束系统变得非常简单。此时调用Z3的 `check()` 和 `get_model()` 可以极快地获得一个完整解。

优势：此方法将一个复杂的多变量求解问题，降解为一系列简单的单变量范围推导和随机选择问题，极大地降低了Z3求解器的负担，从而能够快速、连续地生成大量不同的正例。

此外，对于 `||` (OR) 逻辑，系统会随机选择一个分支进行满足，进一步简化了求解空间，提高了用例的多样性。

== 功能项2: 快速生成多个负例

负例的定义是“不满足 `C`”，即满足 `!C`。如果 `C` 是 `C1 && C2 && ...`，则 `!C` 是 `!C1 || !C2 || ...`。直接求解这个庞大的“或”关系是低效的。

本项目采用了一种随机断言翻转（Random Assertion Flipping）的启发式方法：

1.  在`mutateEntrance`函数中，如果目标是生成负例（`positive == 'N'`），则会调用 `random_flip_expr` 函数。
2.  该函数获取原始的所有约束断言（`C1`, `C2`, ...），并随机地将其中一个或多个进行逻辑取反（例如，将 `a > 5` 变为 `!(a > 5)`，即 `a <= 5`）。
3.  然后，系统尝试求解这个被修改过的约束集合。
4.  由于修改后的约束集合必然与原始约束集的一个子集相悖，因此任何求出的解都一定是原始约束的负例。

优势：这种方法巧妙地避开了求解复杂析取范式，通过对原始约束进行微小但关键的“破坏”，快速构造出易于求解且保证为负例的新约束集。

== 功能项3: 多机并行生成不重复的用例

项目通过`main.cpp`中的逻辑实现了高效的多线程并行：

1.  任务划分：主线程根据用户设定的总用例数、正负例比例和线程数，计算出每个子线程需要生成的正、负例数量。
2.  独立实例：为每个子线程创建一个完全独立的 `CConstraintVisitor` 实例。这意味着每个线程都有自己的符号表、Z3求解器上下文和随机数生成器。
3.  随机化隔离：每个线程使用 `std::random_device` 获取不同的随机种子。由于每个线程的求解过程（特别是随机赋值和断言翻转）都依赖于这个独立的随机种子，它们会探索求解空间的不同部分，从而生成不同的用例。
4.  无锁设计：各线程在生成阶段完全独立，不共享任何可变数据，避免了线程同步开销。仅在最后输出日志时使用互斥锁（`std::mutex`）保证终端信息不交错。
5.  内部去重：在每个线程内部，`m_cases`被定义为 `std::unordered_set`，确保单个线程内不会产生重复的用例。

结论：通过任务划分和为每个线程提供独立的、随机初始化的求解环境，系统实现了高效、无冲突的并行用例生成，并保证了最终用例集的高度多样性和低重复率。

== 功能项4: 证明生成的例子符合给定约束

为保证最终交付用例的100%正确性，项目引入了基于QuickJS的独立验证机制：

1.  动态代码生成：在 `writeCases` 函数中，系统将原始C约束文件中的约束表达式（`m_cons_expressions`）拼接成一个JavaScript布尔表达式字符串。
2.  环境模拟：`_LENGTH` 和 `GAUSSIAN` 这两个C中的特殊函数，也被翻译成等价的JavaScript函数。
3.  执行与断言：
    -   将Z3求解器生成的JSON用例数据注入到QuickJS的全局作用域中。
    -   执行拼接好的JS约束表达式。
    -   获取JS脚本的布尔返回值。
4.  最终检查：
    -   如果目标是正例，则断言JS返回值为 `true`。
    -   如果目标是负例，则断言JS返回值为 `false`。
    -   只有通过断言检查的用例才会被写入文件。

优势：这是一个强大的端到端验证。它独立于核心的Z3求解流程，能有效地捕获从C代码到Z3符号、再到JSON数值整个转换链条中可能出现的任何错误，为用例的正确性提供了坚实的保障。

= 工具测试

为了验证生成器在功能上的完备性、正确性以及在性能上的高效性，我们设计并执行了一系列功能测试和性能基准测试。

== 功能测试

功能测试旨在验证工具是否能正确解析和处理C11语法子集中的各种变量声明和约束逻辑。我们编写了一系列具有针对性的约束文件，每个文件侧重于测试系统的某个特定方面。

#figure(
  three-line-table(
    columns: (1fr, 4fr),
    align: (center, left)
  )[
    | *测试用例*     | #align(center, [*测试目标*]) |
    | ------------ | -------- |
    | simple_val.c | 基础功能验证：测试最简单的整型变量和基本关系运算（`>`、`<`、`==`）. |
    | free_array.c | 一维数组测试：验证对一维数组的声明、索引访问和约束处理. |
    | ndim_array.c | 多维数组测试：验证对二维及更高维度数组的正确解析和符号化. |
    | cons3.c      | 算术运算测试：集中测试加（`+`）、减（`-`）、乘（`*`）、除（`/`）、模（`%`）等算术表达式的转换与求解. |
    | cons4.c      | 逻辑运算测试：测试逻辑与（`&&`）、逻辑或（`||`）、逻辑非（`!`）以及它们组合形成的复杂逻辑链. |
    | cons5.c      | 混合约束测试：结合算术运算、结构体成员访问和数组索引，测试系统在复杂混合场景下的处理能力. |
    | cons1.c     | 综合样例：作为提供给用户的标准样例，覆盖了大部分核心功能，包括基本类型、数组、结构体、`_LENGTH`和`GAUSSIAN`原语. |
    ],
    // columns: (1fr, 3fr),
  caption: [测试用例设计]
)

*测试结果：*
所有功能测试用例均成功执行。测试结果表明，本工具能够正确解析所有测试场景中的变量声明和约束逻辑，并生成符合预期的正例和负例。所有生成的用例均100%通过了独立的QuickJS验证流程，证明了工具在功能层面的正确性和健壮性。

== 性能测试

性能是衡量本工具实用性的关键指标，尤其是在需要生成大规模测试集的场景下。性能测试旨在评估工具在处理复杂约束时生成大量用例的效率，并验证多线程并行架构带来的性能提升。

*测试环境与设置：*

- 测试任务：生成10,000个正例和10,000个负例，共计20,000个测试用例。

- 约束文件 (`cons_complex.c`)：为充分评估工具在复杂场景下的性能，我们设计了一个包含多种数据结构和大量约束的 `cons_complex.c` 文件。该文件定义了多个结构体，声明了包含基本类型、数组、结构体数组在内的多种变量，并在 `_CONSTRAINT` 函数中设置了超过20条相互关联的约束。


*运行命令*：

- 单线程：`./main -n 20000 -p 0.5 -c ./constraint-examples/cons_complex.c`
- 多线程：`./main -n 20000 -p 0.5 -c ./constraint-examples/cons_complex.c -j14`

=== 测试结果与分析

#figure(
  three-line-table[
    | 测试模式 | 完成20,000个用例耗时(正负例各1/2) |
    | ------- | ----------------------------- |
    | 单线程 | > 20分钟 |
    |多线程（14线程） | 约 3分钟 |
  ],
  caption: [性能测试结果]
)

*结果分析*：

测试结果清晰地展示了多线程并行处理带来的巨大性能优势。

1.  单线程性能：在单线程模式下，面对`cons_complex.c`这样复杂的约束集，生成20,000个用例的耗时超过了20分钟。这反映了在复杂场景下，串行化地进行“范围推导 -> 随机赋值 -> 约束求解 -> 验证输出”这一系列操作，其计算成本是相当高的。

2.  多线程性能与加速比：切换到14线程并行模式后，完成相同任务的总时间锐减至约3分钟，性能提升了近7倍。这一显著提升得益于我们精心设计的并行架构：每个线程都在独立的求解环境和随机种子的引导下工作，任务被有效分摊到多个CPU核心上，且线程间无需通信和同步，有效避免了锁竞争和资源冲突。这使得计算能力能够随着核心数的增加而得到有效扩展。

== 测试结论

综合功能与性能测试，我们可以得出以下结论：

-   功能完备：本工具完整覆盖了设计需求，能够正确处理包括基本类型、多维数组、结构体、指针以及特殊原语在内的多种C语言特性和约束。
-   性能卓越：工具在处理复杂约束和大规模用例生成任务时表现出色，其多线程架构带来了显著的性能提升，在现代多核处理器上展现了卓越的扩展能力。

测试结果充分证明，该工具能够胜任在实际软件开发和测试项目中，快速、大批量地生成高质量、多样化测试用例的任务。



