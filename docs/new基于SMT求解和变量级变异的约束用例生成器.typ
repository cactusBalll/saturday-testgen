#import "ori-xjle.typ": *
#import "authors.typ": *
#import "bilingual-bibliography.typ": bilingual-bibliography
#import "@preview/fletcher:0.5.8" as fletcher: diagram, node, edge, shapes
#set heading(numbering: numbly("{1:1}. ", default: "1.1  "))
#show: ori.with(
  author: authors,
  subject: "基于SMT求解和变量级变异的约束用例生成器",
  date: datetime.today(),
  maketitle: true,
  size: 12pt,
  first-line-indent: auto,
  makeoutline: true,
  course: "软件分析与测试",
  font: (
    main: "Times New Roman",
    mono: "Menlo",
    heading: "SimHei",
    cjk: "Songti SC",
    emph-cjk: "Songti SC",
    math: "New Computer Modern Math",
    math-cjk: "Noto Serif SC",
  )
)

= 需求分析

在软件测试，特别是系统级和单元测试中，构造高质量的测试用例是一项耗时且复杂的任务。测试用例需要覆盖各种边界条件和复杂逻辑路径，以确保代码的健壮性和正确性。手动编写这些用例不仅效率低下，而且容易遗漏关键场景。
为了在一定程度上解决这一问题，本项目旨在开发一个自动化、高效、可定制的测试用例生成器。该生成器能够解析以C11语法子集定义的变量及其约束关系，并自动生成大量满足（或不满足）这些约束的测试数据。

从输入、约束条件、输出等方面对本项目的需求进行全面分析，概括如下：

1. *C11语法文本输入*：一个使用C11语法定义的约束描述文件。支持定义的类型有：
  - 数据结构定义: struct，定义了复合数据类型。
  - 特殊函数: \_LENGTH, GAUSSIAN。这些函数是约束系统中的“约束原语”，需要特殊处理。
  - 约束函数: \_CONSTRAINT() 函数体内的表达式集合，它们是核心的约束规则。
2. *约束条件*：
  - 布尔与算术约束: 例如 a > 5 && a < 10, a + b[0] != s[0].a。这些约束可以使用SMT（Satisfiability Modulo Theories）求解器处理，也可以使用模糊测试方法并基于某些启发式算法求解@borzacchiello_fuzzing_2021。
  - 数组/结构体约束: 约束涉及数组元素 (如b[1]) 和结构体成员 (如s[0].a)，且两者可以嵌套（s[0].arr[1]）并支持多维数组(s[0][1][2])。
  - 约束原语:
    - \_LENGTH(void \*p) > 6: 这是对指针p指向的内存区域的数组长度进行约束，实际上是在定义一个动态分配的数组的长度。
    - GAUSSIAN(s[0].c, 1.0, 1.0): 这是对变量概率分布的约束。它表示变量s[0].c的值应该服从给定的高斯分布$G(mu=1.0,sigma=1.0)$。
3. *测试样例输出*
  - 正例：一组满足所有约束的变量赋值。
  - 负例：一组至少违反一个约束的变量赋值。
  - 格式: 清晰的键值对，如 a=7; b[0]=1; ...。可以考虑使用JSON等已有的数据交换格式。
4. *其它需求*
    - 并行生成: 系统应能部署在多台机器上，协同工作。

本项目的难点在于：
- 如何将C11语言定义的约束文件，准确转换成机器可处理的符号？本项目需要解析变量声明、类型定义和约束表达式。
- 如何将不同类型的约束（算术、逻辑、约束原语）统一到一个模型中，特别是 \_LENGTH 和 GAUSSIAN 这种约束原语，Z3@de_moura_z3_2008 等标准求解器无法直接理解。
- 如何系统性地、有针对性地生成违反特定约束的用例，而不是随机地产生一个无效数据。

部分已有工作在设计和实现上接近本项目的需求。对于生成满足约束的测试用例而言，混合模糊测试结合了随机生成用例的灰盒模糊测试和动态符号执行以高效生成用例。QSYM@yun_qsym_2018\工具基于Intel Pin@luk_pin_2005\动态插桩工具，在二进制指令层面生成约束条件并进行求解。KLEE@cadar_klee_2008\符号执行工具解释执行LLVM@lattner_llvm_2002 bitcode并动态构建约束并求解以生成测试用例。SYMCC@poeplau_symbolic_2020\通过在LLVM上编译插桩替代解释执行优化了约束收集的性能，它们都使用Z3@de_moura_z3_2008\作为求解工具。另一方面，使用特定启发式算法的模糊测试工具尝试在不使用SMT求解工具的情况下生成符合约束的测试用例。Fuzzolic@borzacchiello_fuzzing_2021\工具使用fuzz方法求解SMT形式的约束，FOX@she_fox_2024\使用随机控制算法求解在程序中收集的约束条件。

本项目需要处理的输入约束一方面比完整程序简单，所以不需要实现完整的符号执行程序。另一方面输入约束不是完全合法的C程序且具有不同的语义，所以使用已有编译工具链不能得到有效输出，也就很难在IR层面进行约束生成。所以本项目选择在前端AST层面进行分析，生成易于处理的约束表达形式，再基于此输出满足条件的测试用例。
= 架构设计

== 功能架构

本系统将复杂的样例生成任务分解为一系列独立的、顺序执行的功能模块，每个模块各司其职，互相合作，以便实现预期的效果。多线程机制则同时启动多个样例生成实例，然后并行运行这些功能模块。这些功能模块的介绍如下：

+  *命令行选项解析模块*：负责解析用户输入的参数，生成全局的系统参数。命令行参数帮助信息如下所示,其意义如@tlb:cmd\所示。
  ```
  usage: ./main --num_cases=int --pos_ratio=double --cons=string [options] ...
  options:
    -n, --num_cases    number of testcases to be generated (int)
    -p, --pos_ratio    ratio of positive test cases (double)
    -c, --cons         constraint file path (string)
    -o, --output       output cases store path (string [=out])
    -v, --verbose      verbose output
    -j, --thread       number of threads (int [=1])
    -?, --help         print this message
  ```
  #figure(
    three-line-table[
      | 命令行选项 | 功能 |
      | -------- | ---- |
      |-n, --num_cases | 生成样例总数 |
      |-p, --pos_ratio | 生成正样例占总样例数比例 |
      |-c, --cons | 约束文件路径 |
      |-o, --output | 输出样例保存路径 |
      |-v, --verbose | 显示更多调试输出 |
      |-j, --thread  | 并行生成使用线程数量 |
    ],
    caption: [命令行选项功能介绍]
  )<tlb:cmd>
+  *并行执行管理模块*：根据用户指定的线程数，创建多个工作线程，并将总任务量（正负例数量）合理分配给每个线程。
+  *约束解析模块 (ANTLR)*：使用ANTLRv4生成C11语法分析器，通过该分析器可以将输入的约束文件（`.c`）解析为一棵抽象语法树（AST）。具体而言：
  - ANTLRv4是Java实现的解析器生成器，除了原生支持的Java之外，它也提供了C++、Python等语言的运行时。在提供了EBNF文法(\*.g4文件,ANTLR仓库提供了常见语言，包括C11的文法定义)后，它可以生成对应语言实现的parser。
  - 获得ANTLR解析生成的语法树后，使用ANTLR Visitor API可以访问语法树中的各节点。即访问器模式继承Visitor接口实现对应各语法规则的虚函数以实现实际处理逻辑。
+  *符号化转换模块 (AST Visitor)*：核心模块，通过遍历AST，将C代码中的实体和逻辑转换为Z3 SMT Solver@de_moura_z3_2008\支持的表达式，以便进一步处理。主要包含以下两个功能：
  -  变量与符号表：识别C代码中的变量声明（如 `int a`, `S1 s[2]`），并在程序内部维护一个符号表（`SymbolTable`），记录每个变量的名称、类型、维度等信息，并为其创建对应的Z3符号变量。
  -  约束与Z3表达式：遍历 `_CONSTRAINT()` 函数体内的表达式，将C语言的算术、关系和逻辑运算逐一翻译成等价的Z3约束表达式（`z3::expr`）。例如，C代码 `a > 5 && b[0] < 10` 会被转换为Z3中的逻辑与表达式:  `(and (a > 5) ((select b 0) < 10))`，这个转换的过程是通过在语法树上递归自底向上依次构建子表达式实现的。
+  *约束求解器 (Z3 SMT Solver)*：Z3 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定约束条件寻求一组满足条件的解的问题，通过Z3可以方便的求出满足条件的一组解。
+  *变量级变异模块*：这是本系统变异生成多组测试样例的核心模块。它根据原始约束，维护每个变量的可取范围，并递归的对约束变量依次进行变异，即对每个变量在其取值范围内随机赋予一个值，并向Z3求解器中动态增删变异赋值约束，从而实现快速生成大量测试样例的效果。
+  *用例序列化模块 (nlohmann/json)*：将求解引擎得到的具体数值解（即变量的一组赋值），按照变量名组织并序列化为符合输出格式的JSON对象。
+  *用例验证模块 (QuickJS)*：在本系统中，使用JavaScript对生成的样例进行快速验证。具体步骤：
    -   在将样例写入文件前，程序启动一个轻量级JavaScript引擎（QuickJS）。
    -   将原始的C约束逻辑动态转换为JS代码，并将序列化后的JSON用例作为输入，在JS环境中执行验证。
    -   只有通过验证的用例才会被最终输出，确保了100%的正确性。
+  *文件输出模块*：将通过验证的JSON用例写入到指定的输出目录，并根据正负例和序号命名。

== 数据架构

系统在运行过程中处理和流转的核心数据结构主要有：

1.   抽象语法树 (AST - `antlr4::tree::ParseTree`)：由ANTLR生成的、对C约束文件的树状结构化表示，是后续分析的起点。
2.   符号表 (`ststgen::SymbolTable`)：一个分层的作用域哈希表，用于存储从AST中解析出的所有变量信息。其核心是 `SymbolTableEntry` 结构体，描述了变量的类型、限定符（如指针、数组）、维度、约束（如高斯分布参数）以及其对应的Z3符号。
3.   结构体蓝图 (`ststgen::StructBlueprint`)：用于存储`struct`类型的定义，包括其成员变量的名称、类型，以及Z3中对应的元组（Tuple）构造器和访问器函数。
4.   符号化表达式 (`z3::expr`)：Z3库的核心数据结构，以数学形式表示变量间的约束关系。`_CONSTRAINT()` 函数中的每个C表达式最终都被表达为一个 `z3::expr` 对象。
5.   Z3求解器 (`z3::solver`)：求解器对象，可以向其中动态增删约束表达式，支持通过`check()`函数检查当前约束状态是否存在解，通过`solve()`函数可以求出一组可行解。
6.   约束变量数组（`std::vector<z3::expr>`）, 以及包含特定约束变量的约束表达式映射（`std::map<std::string, std::vector<z3::expr>>`）：这两个数据结构是用例变异过程中的使用的核心数据，其中约束变量数组保存了`_CONSTRAINT()`函数中所遇到的每一个原子变量（如单个int型变量`a`，数组的第i个元素`b[0]`， 数组长度`_LENGTH(s[0].d)`等），将其收集起来以便逐个进行变异生成；另外一个数据结构，即包含特定约束变量的约束表达式映射中，可以通过给定的变量名，快速检索出与之相关联的所有约束表达式，用于在变异中更新变量的取值范围。
7.   测试用例赋值 (`nlohmann::json`)：最终输出的数据形式，是一个JSON对象，易于其他软件解析和使用。

== 技术架构

本项目使用C++17实现，使用CMake#footnote[https://cmake.org/]作为构建工具，vcpkg#footnote[https://vcpkg.io/]用于包管理，C++17可以满足本项目对于内存访问和线程细粒度控制的需求。

在本项目的实现过程中，使用了以下业界成熟的第三方库：

1.   ANTLRv4#footnote[https://www.antlr.org/]：强大的语法分析器生成器，用于解析C11语法，构建AST。ANTLRv4解析EBNF文法生成parser源代码而不是解释执行EBNF文法定义，源代码最终会被编译为原生二进制程序，这为其提供了较好的性能。
2.   Z3 SMT Solver (Microsoft)#footnote[https://github.com/Z3Prover/]：世界领先的约束满足理论（SMT）求解器。是本项目的“大脑”，负责处理所有符号计算和约束求解任务。本项目直接调用Z3++.h API与Z3求解器交互，最大程度地节省了约束求解的开销。
3.   QuickJS#footnote[https://bellard.org/quickjs/]：轻量、快速的嵌入式JavaScript引擎，用于在C++环境中执行独立的用例验证逻辑，实际使用了QuickJS-NG分支以支持在Windows下运行。
4.   nlohmann/json#footnote[https://github.com/nlohmann/json]：业界知名的用于处理JSON数据的头文件库。本项目最终输出的样例使用JSON文档表示。
5.   cmdline.h#footnote[https://github.com/tanakh/cmdline]：用于C++命令行参数解析的头文件库。
6.   fmtlib#footnote[https://github.com/fmtlib/fmt]：一个高性能的格式化库，用于日志和终端输出。

= 实现技术

== 功能项1: 快速生成多个正例

单纯依赖Z3求解器直接对原始约束集合求解，只能生成一组测试样例。为了快速生成多组测试样例，本项目采用了一种原创的变量级随机赋值策略（Variable-level Random Assignment Strategy）来进行样例生成，该算法流程图如@fig:mutate\所示。

算法的详细过程介绍如下：
1.  原子变量识别：在解析C11约束表达式阶段，程序会识别出表达式中的所有“原子变量”（如 `a`, `b[0]`, `s[1].a` 等，它们是具体的数字，而不是复合类型），然后将这些原子变量存入约束变量集合`val_set` 中，同时建立约束变量表达式映射`val_expr_map`。
2.  递归变异生成测试样例：通过 `mutateVar` 函数递归地遍历约束变量集合`val_set`。对每个变量，它会：
    -   更新取值范围：基于已经赋过值的变量，简化与当前变量相关的约束，从而推导出该变量的有效取值范围（例如，从 `a > 5 && a < 10` 推导出 `a` 的范围是 `[6, 9]`）。
    -   随机赋予：在当前变量的有效范围内，随机为变量赋予一个具体值。
    -   添加新约束并递归：将“`变量 == 赋予值`”作为一个新的、临时的约束添加到Z3求解器中。
    -   求解：若当前求解器能够进行求解，则可取得一组测试样例。
    -   递归变异下一个变量：调用`mutateVal(val_i.next())`，以便继续对下一个变量进行处理。
    -   删除临时约束：最后需要在求解器中删除本轮赋予的随机值约束。
3.  最终求解：当所有变量都被赋予具体值后，递归到最深层次，再次对当前求解器进行求解，取得一组测试样例。

优势：此方法将一个复杂的多变量求解问题，降解为一系列简单的单变量范围推导和随机赋值问题，从而能够快速、连续地生成大量不同的测试样例。

此外，对于 `||` (OR) 逻辑，程序会随机选择一个分支进行满足，进一步提高了用例的多样性。

#figure(
  text(
    size: 10pt,
    font: "SimHei",
  diagram(
    
    node-stroke: 1pt,

    node((0,0), [开始：解析C11约束文件\ 识别约束变量\ 构建约束变量集合`val_set` \ 建立约束变量表达式映射`val_expr_map` ], corner-radius: 2pt),
    edge("-|>"),
    node((0,1), [启动变异生成：`mutateVal(val_set.begin())`], corner-radius: 2pt),
    edge("-|>"),
    node((0,2), [对第`i`个变量进行变异生成：`mutateVal(val_i)`], corner-radius: 2pt),
    edge("-|>"),
    node((0,3), [`val_i == val_set.end() ?`], shape: shapes.diamond, height: 2em),
    edge("-|>", label: [是]),
    node((1,3), [求解\ 输出一组样例], corner-radius: 2pt),
    edge("-|>"),
    node((1,4), [递归终止\ 返回上一层], corner-radius: 2pt),
    edge((0,3), (0,4),"-|>",label: "否"),
    node((0,4), [遍历`val_expr_map`\ 检索包含`val_i`的所有约束表达式 \ 更新`val_i`取值范围], corner-radius: 2pt),
    edge("-|>"),
    node((0,5), [在`val_i`取值范围内\ 为`val_i`随机赋值], corner-radius: 2pt),
    edge("-|>"),
    node((0,6), [将`val_i`随机赋值作为约束\ 添加进SMT求解器中], corner-radius: 2pt),
    edge("-|>"),
    node((0,7), [求解器是否存在解 ?], shape: shapes.diamond, height: 2em),
    edge("-|>", label: "存在"),
    edge((0,7), "l,d,d,d,r","-|>", label: "不存在", label-pos: 10%),
    node((0,8), [求解并输出一组样例], corner-radius: 2pt),
    edge("-|>"),
    node((0,9), [递归变异下一个变量\ `mutateVal(val_i.next())`], corner-radius: 2pt),
    edge("-|>"),
    node((0,10), [在求解器中移除当前`val_i`的赋值约束], corner-radius: 2pt),
    edge("-|>"),
    edge((1,4),"d,d,d,d,d,d,l","-|>"),
    node((0,11), [结束], corner-radius: 2pt),
    )
  ),
  caption: [变异生成测试样例算法流程图]
)<fig:mutate>

== 功能项2: 快速生成多个负例

负例的生成采用随机断言翻转（Random Assertion Flipping）的方法，即将原始约束集合中的部分约束进行翻转，再按照上述过程生成测试样例，与前述正例生成不同之处在于：

1.  在解析完成C11约束文件后，会调用 `random_flip_expr` 函数对原始约束进行部分（或全部）随机翻转。（例如，将 `a > 5` 变为 `!(a > 5)`，即 `a <= 5`）。
2.  然后，程序按照3.1节所述算法尝试为这个被修改过的约束集合输出测试样例，但是在递归过程中，不会更新变量的取值范围，所有约束变量将在合理范围内被随机赋值。
3.  由于修改后的约束集合必然与原始约束集的一个子集相悖，因此任何求出的解都一定是原始约束的负例。

优势：这种方法通过对原始约束进行随机翻转，快速构造出易于求解且保证为负例的新约束集。最大程度复用了正例生成的相关代码。

== 功能项3: 多机并行生成不重复的用例

本项目通过C++的线程对象实现了高效的多线程并行求解，具体包括以下步骤：

1.  任务划分：主线程根据用户设定的总用例数、正负例比例和线程数，计算出每个子线程需要生成的正、负例数量。
2.  独立实例：为每个子线程创建一个完全独立的 `CConstraintVisitor` 实例。这意味着每个线程都有自己的符号表、Z3求解器上下文和随机数生成器。
3.  随机化隔离：每个线程使用 `std::random_device` 获取不同的随机种子。由于每个线程的求解过程（特别是随机赋值和断言翻转）都依赖于这个独立的随机种子，它们会探索变异空间的不同部分，从而生成不同的用例。
4.  无锁设计：各线程在生成阶段完全独立，不共享任何可变数据，避免了线程同步开销。仅在最后输出日志时使用互斥锁（`std::mutex`）保证终端信息不交错。
5.  内部去重：在每个线程内部，`m_cases`被定义为 `std::unordered_set`，确保单个线程内不会产生重复的用例。

结论：通过任务划分和为每个线程提供独立的、随机初始化的求解环境，系统实现了高效、无冲突的并行用例生成，并保证了最终用例集的高度多样性和低重复率。

== 功能项4: 证明生成的例子符合给定约束

为保证最终交付用例的100%正确性，项目引入了基于QuickJS的独立验证机制。本项目生成的样例JSON形式和对应的约束声明如下所示。其中键值对表示变量名和对应赋值。JSON数组表示约束中的数组，而JSON对象表示struct结构体。
#grid(
  columns: (1fr,1fr),
  gutter: 1em,
  [
    ```json
{
    "a": 0,
    "b": [0, 0, 0],
    "s": [{
            "a": 0,
            "b": -1834331339,
            "c": 0.9329867027,
            "d": [] 
          },{
            "a": 8,
            "b": -783029840,
            "c": 2.0,
            "d": [] 
            } ]
}
```],
[
    ```c
typedef struct {
    int a;
    int b;
    double c;
    int* d;
} S1;

int a;
int b[3];
struct S1 s[2];
```
  ]
)

因为JSON是JavaScript的子集，本项目可以方便地使用JavaScript解释器验证生成样例地正确性。具体流程如下：

1.  动态代码生成：在 `writeCases` 函数中，系统将原始C约束文件中的约束表达式（`m_cons_expressions`）转换为一个JavaScript布尔表达式字符串。
2.  环境模拟：`_LENGTH` 和 `GAUSSIAN` 这两个C中的特殊函数，也被翻译成等价的JavaScript函数。
3.  执行与断言：
    -   将Z3求解器生成的JSON用例数据注入到QuickJS的全局作用域中。
    -   执行拼接好的JS约束表达式。
    -   获取JS脚本的布尔返回值。
4.  最终检查：
    -   如果目标是正例，则断言JS返回值为 `true`。
    -   如果目标是负例，则断言JS返回值为 `false`。
    -   只有通过断言检查的用例才会被写入文件。

一个生成验证代码的例子如下所示。
```js
var f = () => {
    var _LENGTH = (e) => {
        return e.length;
    };
    var GAUSSIAN = (v, miu, va) => {
        return true;
    };
    Object.assign(this,
        {
            "a": 6, "b": [0, 0, -1],
            "s": [
              {"a": 7, "b": 0, "c": 2.0, "d": [14,15,16,17,18,19,0]}, 
              {"a": 11, "b": 0, "c": 3.0, "d": [14,15,16,17,18,19, 0]}
            ]
        }
    );
    return (a > 5 && a < 10) &&
           (b[1] > b[2] || b[0] < b[1]) && 
           (a + b[0] != s[0].a) && 
           (_LENGTH(s[0].d) > 6 && _LENGTH(s[0].d) < 10) &&
           (_LENGTH(s[1].d) > 6 && _LENGTH(s[1].d) < 10) && 
           (s[0].d[6] + s[1].d[6] == s[0].b * s[1].b);
};
f();

```

这种验证方法的优势在于相对于重新实现样例验证逻辑，QuickJS引擎本身的正确性是可以保证的（它通过Test262: ECMAScript Test Suite和模糊测试进行了较为完整的测试），所以本项目使用QuickJS可以有效验证生成样例的正确性。同时，QuickJS引擎独立于核心的变异和约束求解算法，能有效地捕获从C代码到Z3符号、变异后中间表示、再到JSON输出整个转换链条中可能出现的任何错误，为用例的正确性提供保障。

= 工具测试

为了验证生成器在功能上的完备性、正确性以及在性能上的高效性，我们设计并执行了一系列功能测试和性能基准测试。

== 功能测试

功能测试旨在验证工具是否能正确解析和处理C11语法子集中的各种变量声明和约束逻辑。我们编写了一系列具有针对性的约束文件，每个文件侧重于测试系统的某个特定方面，@tlb:func-test\所示。

#figure(
  three-line-table(
    columns: (1fr, 4fr),
    align: (center, left)
  )[
    | *测试用例*     | #align(center, [*测试目标*]) |
    | ------------ | -------- |
    | simple_val.c | 基础功能验证：测试最简单的整型变量和基本关系运算（`>`、`<`、`==`）. |
    | free_array.c | 一维数组测试：验证对一维数组的声明、索引访问和约束处理. |
    | ndim_array.c | 多维数组测试：验证对二维及更高维度数组的正确解析和符号化. |
    | cons3.c      | 算术运算测试：集中测试加（`+`）、减（`-`）、乘（`*`）、除（`/`）、模（`%`）等算术表达式的转换与求解. |
    | cons4.c      | 逻辑运算测试：测试逻辑与（`&&`）、逻辑或（`||`）、逻辑非（`!`）以及它们组合形成的复杂逻辑链. |
    | cons5.c      | 混合约束测试：结合算术运算、结构体成员访问和数组索引，测试系统在复杂混合场景下的处理能力. |
    | cons1.c     | 综合样例：作为提供给用户的标准样例，覆盖了大部分核心功能，包括基本类型、数组、结构体、`_LENGTH`和`GAUSSIAN`原语. |
    ],
    // columns: (1fr, 3fr),
  caption: [测试用例设计]
)<tlb:func-test>

*测试结果：*
所有功能测试用例均成功执行。测试结果表明，本工具能够正确解析所有测试场景中的变量声明和约束逻辑，并生成符合预期的正例和负例。所有生成的用例均100%通过了独立的QuickJS验证流程，证明了工具在功能层面的正确性和健壮性。

== 性能测试

性能是衡量本工具实用性的关键指标，尤其是在需要生成大规模测试集的场景下。性能测试旨在评估工具在处理复杂约束时生成大量用例的效率，并验证多线程并行架构带来的性能提升。

*测试环境与设置：*

- 测试任务：生成10,000个正例和10,000个负例，共计20,000个测试用例。

- 约束文件 (`cons_complex.c`)：为充分评估工具在复杂场景下的性能，我们设计了一个包含多种数据结构和大量约束的 `cons_complex.c` 文件。该文件定义了多个结构体，声明了包含基本类型、数组、结构体数组在内的多种变量，并在 `_CONSTRAINT` 函数中设置了超过20条相互关联的约束。


*运行命令*：

- 单线程：`./main -n 20000 -p 0.5 -c ./constraint-examples/cons_complex.c`
- 多线程：`./main -n 20000 -p 0.5 -c ./constraint-examples/cons_complex.c -j14`

=== 测试结果与分析

测试结果如@tlb:perf-test\所示，测试结果清晰地展示了多线程并行处理相对于单线程处理实现了有效的性能优化。

1.  单线程性能：在单线程模式下，面对`cons_complex.c`这样复杂的约束集，生成20,000个用例的耗时超过了20分钟。这反映了在复杂场景下，串行化地进行“范围推导 -> 随机赋值 -> 约束求解 -> 验证输出”这一系列操作，其计算成本是相当高的。

2.  多线程性能与加速比：切换到14线程并行模式后，完成相同任务的总时间减少至约3分钟，性能提升了近7倍。这一显著提升得益于我们精心设计的并行架构：每个线程都在独立的求解环境和随机种子的引导下工作，任务被有效分摊到多个CPU核心上，且线程间无需通信和同步，有效避免了锁竞争和资源冲突。这使得计算能力能够随着核心数的增加而得到有效扩展。

#figure(
  three-line-table[
    | 测试模式 | 完成20,000个用例耗时(正负例各1/2) |
    | ------- | ----------------------------- |
    | 单线程 | > 20分钟 |
    |多线程（14线程） | 约 3分钟 |
  ],
  caption: [性能测试结果]
)<tlb:perf-test>

== 测试结论

综合功能与性能测试，本项目实现的工具功能完备，完整覆盖了设计需求，能够正确处理包括基本类型、多维数组、结构体、指针以及特殊原语在内的多种C语言特性和约束。同时，本项目实现的工具具有较为优秀的性能。工具在处理复杂约束和大规模用例生成任务时表现出色，其多线程架构带来了显著的性能提升，在现代多核处理器上展现了有效的扩展能力。

测试结果充分证明，该工具能够胜任在实际软件开发和测试项目中，快速、大批量地生成高质量、多样化测试用例的任务。

= 参考文献

// 使用GB7714-15格式引用文献
#bilingual-bibliography(
  title: none,
  style: "gb-7714-2015-numeric.csl",
  bibliography: std.bibliography.with("b.bib"),
)

